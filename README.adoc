# Post-Quantum WebAuthn Test Platform

**Deployed Web Service:**  https://python-fido2-webauthn-test.onrender.com

**Note:** The Docker image in this repo builds `liboqs` and its Python bindings from source so the
demo is PQC-ready without any host-level setup.

== üö¢ Containerised deployment

The repository now contains a multi-stage `Dockerfile` that builds liboqs from source, compiles the
matching `liboqs-python` bindings, and runs the Flask demo with Gunicorn.  This container is
self-contained and works on Render or any other Docker-capable platform.

=== Build the image

[,shell]
----
docker build -t webauthn-pqc .
----

=== Run locally

[,shell]
----
docker run --rm -p 8000:8000 webauthn-pqc
----

The container uses the `PORT` environment variable when supplied by a hosting service, defaulting to
`8000` for local testing.  liboqs is installed under `/opt/liboqs` and made available to the
`oqs` Python package automatically, so Post-Quantum algorithms can be exercised without any manual
host configuration.  The Flask demo is served via Gunicorn using the command
`gunicorn --bind 0.0.0.0:${PORT:-8000} server.app:app`.

=== Render deployment strategy (conceptual)

Render offers two runtimes: a language-specific environment (the default ‚ÄúPython‚Äù runtime) and a
Docker runtime. The Python runtime does **not** include the Docker CLI, so attempts to run
`docker build` there fail with `docker: command not found`. Because this project requires compiling
liboqs and linking `liboqs-python` against those libraries, deployments need full control of the
system image. The sustainable approach is therefore to migrate the service to Render's Docker
runtime, letting the platform build the provided Dockerfile rather than invoking `pip` inside the
Python sandbox.

==== Migrate the existing service to the Docker runtime

If the service was originally provisioned as a Python app, update it before the next deploy:

1. In the Render dashboard open the service, choose **Settings ‚Üí Environment**, and change the
   runtime to **Docker**. Render may require recreating the service under the Docker runtime; if so,
   create a new Web Service, select Docker as the environment, and point it at this repository.
2. Confirm the generated configuration matches the supplied `render.yaml`, in particular the
   `runtime: docker` stanza (or `env: docker` on older blueprints) and the use of the root
   `Dockerfile` as the build source. Leave the Build and Start command fields empty so Render knows
   to execute the Dockerfile directly; nothing should invoke `docker build` inside the Python
   runtime.
3. Trigger a fresh deploy. A successful migration prints `Using Dockerfile: ./Dockerfile` near the
   top of the logs and no longer shows the Python runtime banner (`Using Python version ‚Ä¶`).

==== Conceptual image composition

With the runtime switched, the migration plan is purely procedural‚Äîno additional Render YAML or
scripts are required beyond the existing Dockerfile:

1. **Create a Docker service in Render.** When creating the service choose the Docker runtime, point
   the build context at this repository, and allow Render to clone it directly. Seeing cloning logs
   that reference this public repository confirms the service has access; if Render reports a
   permissions issue, update the repository visibility or deploy key before proceeding.
2. **Let Render execute the Dockerfile.** With the Build and Start command fields blank, Render runs
   the multi-stage Dockerfile itself. The build stages should:
   * Base on a supported Python image (e.g., `python:3.12-slim`) to guarantee compatibility with the
     application runtime.
   * Install OS-level build tooling (build-essential, cmake, ninja, pkg-config) plus crypto
     prerequisites (OpenSSL headers, libcurl if required) so liboqs can compile.
   * Clone and build liboqs with shared libraries enabled, install it under a prefix like
     `/opt/liboqs`, and expose that path via `LD_LIBRARY_PATH` in later stages.
   * Fetch matching `liboqs-python` sources, point the build at the staged liboqs artifacts, and
     `pip install` the wheel into the runtime layer.
   * Install application dependencies (from `requirements.txt` or Poetry export) and copy the Flask
     WebAuthn server code into the image.
3. **Confirm the runtime entry point.** The final stage should run
   `gunicorn --bind 0.0.0.0:${PORT:-8000} server.app:app` so that the container listens on the port
   Render injects at deploy time, preserving the same API surface used by the existing service.
4. **Validate locally before pushing.** Build the Docker image on a developer workstation or CI
   runner to verify that liboqs and `oqs` import successfully. This local parity ensures that the
   Render build sees the same environment, preventing surprises during deployment.
5. **Redeploy and monitor.** After switching the Render service to the Docker runtime, trigger a
   deployment. The logs should now show the Docker build output (multi-stage compilation, pip
   installs, etc.) rather than `Using Python version ‚Ä¶`. Once the container starts, confirm that
   PQC registration/auth flows succeed, proving the bundled libraries load correctly.

==== Deployment debugging checklist

If a redeploy still prints `Using Python version ‚Ä¶` or fails with `docker: command not found`, walk
through this checklist:

* **Service type:** Existing services created as Python apps stay on the native runtime even after
  commits add a Dockerfile. Recreate the service and choose **Docker** as the environment to unlock
  Docker builds.
* **Blueprint runtime:** Ensure `render.yaml` lives at the repository root and declares
  `runtime: docker` for the web service. Render ignores the Dockerfile if the runtime remains set to
  `python`.
* **Dashboard overrides:** In the Render UI verify that Build Command and Start Command are blank.
  Any manual entry overrides Dockerfile execution and can reintroduce `docker build` invocations.
* **Path configuration:** When creating the service confirm the Dockerfile path is `./Dockerfile`
  and the context is the repository root. Misconfigured paths cause Render to fall back to native
  builds.
* **Clean rebuild:** Use **Clear build cache and deploy** or recreate the service to force Render to
  read the updated configuration. Cached Python builds can linger even after switching runtimes.

Once these checks pass, deploy logs should begin with `Using Dockerfile: ./Dockerfile`, proving the
Docker runtime is active and the PQC-enabled image is building end-to-end.

Following this workflow isolates the PQC toolchain inside the container image, eliminating
environment drift between local development, CI, and Render. The Docker runtime becomes the single
source of truth for system libraries, ensuring future updates to liboqs or the WebAuthn application
can be rolled out reproducibly without depending on Render's host Python environment.

A complete test suite for WebAuthn/FIDO2 registration and authentication with Post-Quantum Cryptography (PQC) support.
It displays the selected algorithm, authenticator flags (UP/UV/AT/ED/BE/BS), sign counter, and extension results (credProps, PRF, largeBlob) for validation.  
This test app also supports functionalities such as **decoder**, **FIDO MDS explorer**, etc.  

Built on **python-fido2-PQC**, which extends Yubico‚Äôs **python-fido2**.  

PQC: Currently supporting **ML-DSA-44** (alg: -48), **ML-DSA-65** (alg: -49), and **ML-DSA-87** (alg: -50). 

---

## üíª Local Setup

**Scope**
- Includes: Python, virtual environment, Flask, python-fido2, and Post-Quantum Crypto (PQC) algorithm options.

---

## ‚úÖ Supported Platforms

- Windows 10/11 (64-bit)  
- macOS (Intel or Apple Silicon)  

A modern browser with WebAuthn support is required:
- Edge, Chrome, Safari, Firefox

---

## 1. Prerequisites

- **Git**: (https://git-scm.com/)  
- **Python 3.12+ (64-bit)** with pip (https://www.python.org/downloads/)

---

## 2. Clone the Repository

```bash
git clone https://github.com/rainzhang05/python-fido2-webauthn-test.git
cd python-fido2-webauthn-test
```

---

## 3. Setup ‚Äî pip + venv

### Windows (PowerShell)

```powershell
# Create and activate a virtual environment
py -3.12 -m venv .venv
.\.venv\scripts\activate

# Upgrade pip and install runtime dependencies
python -m pip install --upgrade pip
pip install -r requirements.txt

# Optional: PC/SC smart card extras
pip install "fido2[pcsc]"
```

### macOS

```bash
# Create and activate a virtual environment
python3 -m venv .venv
source .venv/bin/activate

# Upgrade pip and install runtime dependencies
python -m pip install --upgrade pip
pip install -r requirements.txt

# Optional: PC/SC smart card extras
pip install "fido2[pcsc]"
```

## üîê PQC Setup

### 1. Activate Your Python Virtual Environment

**Windows (PowerShell):**
```powershell
.\.venv\scripts\activate
```

**macOS:**
```bash
source .venv/bin/activate
```

### 2. Install PQC Cryptography Libraries

**Using pip / virtualenv**
```bash
pip install ".[pqc]"
python -c "import oqs"
```
### 3. Install Open Quantum Safe (OQS) Libraries: 

#### Install `liboqs`

##### Windows

```powershell
# Clone liboqs
git clone --branch main https://github.com/open-quantum-safe/liboqs.git
cd liboqs

# Configure build
cmake -S . -B build -DOQS_BUILD_SHARED_LIBS=ON -DOQS_USE_OPENSSL=OFF

# Build in Release mode
cmake --build build --config Release
```
Output: build\bin\Release\oqs.dll

Copy the DLL into your Python venv so oqs can find it:

```
copy build\bin\Release\oqs.dll C:\path\to\your\venv\Lib\site-packages\oqs\
```

Or add the folder to your PATH.

##### macOS
```
# Clone liboqs
git clone --branch main https://github.com/open-quantum-safe/liboqs.git
cd liboqs

# Configure and build
cmake -S . -B build -DOQS_BUILD_SHARED_LIBS=ON -DOQS_USE_OPENSSL=OFF
cmake --build build --config Release
```

Output: build/lib/liboqs.dylib

Copy to your venv:

```
cp build/lib/liboqs.dylib /path/to/venv/lib/python3.X/site-packages/oqs/
```

Or add to DYLD_LIBRARY_PATH:

```
export DYLD_LIBRARY_PATH=$PWD/build/lib:$DYLD_LIBRARY_PATH
```

#### 4. Install liboqs-python

Make sure you already built and installed **liboqs** (the C library).  
Now, clone and install the Python wrapper:

```bash
# Go to home directory
cd ~

# Clone liboqs-python
git clone https://github.com/open-quantum-safe/liboqs-python.git
cd liboqs-python

# Install into your active virtual environment
pip install .
```

#### Step 2. Verify Installation

From your **project root** (where your `.venv` is located):

```bash
cd ~/IdeaProjects/python-fido2-webauthn-test
python -c "import oqs; print(oqs.get_version()); print(oqs.get_enabled_sigs())"
```

If installed correctly, you should see something like: 
```
0.14.0-dev
['ML-DSA-44', 'ML-DSA-65', 'ML-DSA-87', ...]
```
This indicates the version number and supported algorithms. Make sure all PQC algorithm that you would like to use appears in the list above. 

---

## üîí mkcert Setup for Local HTTPS

### 1. Install mkcert

#### Windows
```bash
# Install Chocolatey
Set-ExecutionPolicy Bypass -Scope Process -Force; `
  [System.Net.ServicePointManager]::SecurityProtocol = `
  [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; `
  iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
# Install mkcert via Chocolatey
choco install mkcert -y
```

#### macOS
```bash
brew install mkcert
brew install nss   # required for Firefox users
mkcert -install
```

---

### 2. Generate Certificates

**Windows (PowerShell)**
```powershell
cd C:\path\to\your\project
mkcert localhost 127.0.0.1 ::1
```

**macOS (Terminal)**
```bash
cd /path/to/your/project
mkcert localhost 127.0.0.1 ::1
```

‚ö†Ô∏è Important:
- WebAuthn works on `localhost`, **not** `127.0.0.1`.  
- Rename files to:
  - `localhost+1.pem`  
  - `localhost+1-key.pem`  
  Otherwise, the program will fail to run.

---

## üöÄ Quickstart

### 1. Create and Activate Virtual Environment

**Windows (PowerShell)**
```powershell
py -3 -m venv .venv
.\.venv\scripts\activate
```

**macOS**
```bash
python3 -m venv .venv
source .venv/bin/activate
```

---

### 2. Run the Server

```bash
python server/server/app.py
```

Expected output:
```
Running on https://localhost:5000/
```

Click the link to open the test app in your browser.

---

## üìù Notes

- Credentials are saved as `.pkl` files in:  
  `server/server`  
- Deleting credentials in the test app will also delete the corresponding `.pkl` file locally.

---
